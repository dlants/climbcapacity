## Why another view framework?

DCGView is a client-side javascript view library / framework.
It is a way to create a DOM to represent your data, and to update it when that data changes.

Many frameworks handle moving data in both ways (data -> DOM, and DOM -> update model), but DCGView is a one-directional system, data -> DOM.

To understand DCGView, it's helpful to start with what else already exists. In this discussion, we'll talk only about the uni-directional flow for other frameworks.

### Other approaches

#### Change-based systems

Examples of this are: knockout, backbone, ember

In theory, a change-driven system can have the best performance, since when a change occurs only the minimal amount of required work needs to be done (e.g. adding a class to an
element in response to some input), and the rest of the DOM and of the JS machinery doesn't need to be changed. In practice, tracking changes has some significant downsides.

There are more cases for a developer to deal with and get right, leading to room for subtle bugs, and data-flow is frequently hard to follow. Additionally, for non-trivial programs the performance of a naive approach to change-propagation approach can suffer. These performance problems are generally possible to solve, but frequently sacrifice simplicity / readability.

Code is generally represented as a set of JS view classes, plus a set of templates to be populated. In some frameworks, the views can be automatically generated by processing the template code.
As a result, the process of applying diffs and of rendering the initial DOM are separate operations. This is often handled by the framework, by including an update loop in the initial DOM generation.

Answers to problems in these frameworks is generally either "be smarter / think harder" (on the part of the developer), or "more magic" (on the part of the framework).

#### Data-level diffing

The best-known example here is Angular, so I will discuss angular in particular.

One alternative to requiring the developer to provide events that trigger mutations, is to somehow infer them. This is generally done by diffing of some sort.

Angular scopes represent the data needed for the directives to render DOM updates. Directives represent a mapping from that data to what the DOM should look like. Directives register listeners for the data they care about, which can be either specific properties or computed functions, via $watch.  The flow to get data into the DOM is to update the data within a scope, and then let Angular and the directives handle the DOM update.  The data update happens within `scope.$apply()`call (initiated by the framework for all framework-triggered DOM events or the user otherwise). Once the batched scope updates finish, then the`$digest` cycle runs, which provides the updated data to directives which have subscribed to that data, and they make individual updates to the DOM.

In Angular, code is generally represented as a set of templates that include directives, inserted directly into the HTML, as well as the controllers and models required to update the scopes and provide functionality required by the directives in the template. New behaviors and components are frequently built as new directives.

#### DOM-level diffing

Examples in the category are: React, Mithril

A third alternative is to not require the develper to provide either data-change events, or to declare how their view depends on the data. Instead, the developer is just responsible for writing a function which turns their data into the DOM that they want to be in the page. The framework then uses a diff between what was requested and what is currently in the DOM to find an efficient set of operations to update the DOM. That diffing is generally considered to be a performance optimization (e.g. re-rendering the full DOM on every change would be correct, just too slow for nontrivial apps).

Finding efficient changesets between different arbitrary trees is computationally hard, and cannot be done in realtime for arbitrary modifications, so all systems in this category use suboptimal diffing which is optimal for common operations. The contract generally provided for the DOM diffing is that it will correctly convert between any two trees, but it will only efficiently convert between trees where changes are adding / removing nodes, changing node types, and adding / removing / reordering list elements which are identified with unique keys.

In this category of system, code is generally represented in a JS-centric way, as a set of JS methods and classes which can generate the DOM desired based on the data. As a result, instead of specifying in HTML or external templates, the desired DOM is generally generated by a render() method. This method is called on every update and the resulting virtual DOM representation is fed into the frameworks DOM diffing algorithm. To do this, javascript extension languages such as JSX (React) and MSX (Mithril version of JSX) have been developed which make it syntactically nicer to generate DOM from within javascript. New behaviors and components are built as composable components.

The performance assumptions here are that the DOM is slow, and JS is generally far faster - enough so that it is reasonable to regenerate and diff a description of the DOM whenever data might have changed, as long as unnecessary DOM updates are avoided. This holds reasonably well, but introduces significant constant-factor overhead for creating and updating very large DOM trees (many thousands of nodes).

### Our approach

DCGView is a hybrid between data-level and DOM-level diffing. Views are represented as long-lived JS objects which generate their HTML at mount time, and know how to update it in response to changing data. The developer is responsible for declaring which components may update, which allows static sections (individual attributes, and entire child trees) of the DOM to be generated efficiently and skipped completely during updates (in comparison to the DOM-level diffing, which requires adding static classes and children to the virtual DOM on every iteration unless the update is skipped for the entire subtree).

The functions performed by DOM-level diffing are split out into several different responsibilities. For updates to attributes and properties of DOM nodes, DOM-level diffing is done at the per-attribute level (and done only for those attributes which are known to potentially change) by the framework, so instead of re-generating the whole DOM tree, only the dynamic classes and styles need to be re-generated and diffed. Structural changes (e.g. adding / removing / reordering components) are not handled by the core framework, but instead by composable components which can implement contracts which are more tightly bound to the updates which the developer needs, and can listen to only the data they need. As an example, our <For/> components does all addition / removal / reordering computations based on just the list of keys, so the full data for all child elements doesn't need to be regenerated or checked for updates, and no DOM (even virtual DOM) needs to be re-rendered.

We've found it to be a lighter-weight and higher-performance alternative to React, which maintains most of the good developer ergonomics of the DOM-level diffing approach.

### Languages

DCGView is written in pure javascript. That gave us deep control over the core performance. But you probably don't want to try to use DCGView from within a pure javascript file. The syntax is way too verbose. The original idea was that we'd DCGView within coffee script. We did that for a couple years. The syntax was beautiful but the type-checking was terrible. Then TypeScript matured. We've switched to using TypeScript and that means we needed to make DCGView work within TypeScript. There were a few syntax gremlins when we started using it, but that's mostly been worked out. When compared to JSX + React, the syntax is not really any worse, and it might even be slightly better.
